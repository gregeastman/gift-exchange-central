#!/usr/bin/env python
#
# Copyright 2016 Greg Eastman
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from google.appengine.api import users
from google.appengine.ext import ndb
from google.appengine.api import mail

import datamodel

import webapp2
import json

_DEFAULT_GIFT_EXCHANGE_NAME = datamodel._DEFAULT_GIFT_EXCHANGE_NAME
_DEFAULT_MAX_RESULTS = 200

def participant_required(handler):
    """
        Decorator that checks if there's a user associated with the current session.
        Will also fail if there's no session present.
    """
    def check_participant(self, *args, **kwargs):
        gift_exchange_participant = self.get_participant()
        if gift_exchange_participant is None:
            self.redirect('/home', abort=True)
        elif gift_exchange_participant.is_valid_for_google_id(users.get_current_user().user_id()) == False:
            self.redirect('/home', abort=True)
        else:    
            return handler(self, *args, **kwargs)      
    return check_participant

def send_email_helper(participant, subject, content, unsubscribe_link):
    """Helper function for sending an email with the autogenerated content."""
    #is this HTML content?
    body = 'Hello ' + participant.display_name + ',\n\n' + content
    body = body + '\n\n\n-------------------------------------------------------------------------'
    body = body + '\nThis is an auto-generated email from ' + participant.get_event().display_name + '. Please do not reply to this email.'
    body = body + '\nIf you have questions, please email Greg (greg.eastman@gmail.com)'
    plain_text = body
    body = body.replace('\n', '<br />')
    if unsubscribe_link:
        body = body + '<br /><a href="' + unsubscribe_link + '">Unsubscribe from automated updates</a>'
        plain_text = plain_text + '\nUnsubscribe: ' + unsubscribe_link
    message = mail.EmailMessage(
                    sender='anonymous@gift-exchange-central.appspotmail.com',
                    subject=subject)
    message.to = participant.get_user().email
    message.body = plain_text
    message.html = '<html><head></head><body>' + body + '</body></html>'
    message.send()

class MainWebAppHandler(datamodel.BaseHandler):
    """A wrapper about webapp2.RequestHandler with customized methods"""
    def get_participant(self):
        """Gets a participant from the get string gift_exchange_participant"""
        gift_exchange_participant = None
        try:
            participant_string = ''
            #this is a little hacky, but it seems to work
            if self.request.method == 'GET':
                participant_string = self.request.get('gift_exchange_participant')
            else:
                participant_string = json.loads(self.request.body)['gift_exchange_participant']
            participant_key = ndb.Key(urlsafe=participant_string)
            gift_exchange_participant = participant_key.get()
        except:
            pass
        return gift_exchange_participant
    
class LoginHandler(MainWebAppHandler):
    """The class that handles requests for logins"""
    def get(self):
        """Method that handles get requests for the login page"""
        user = users.get_current_user()
        if user:
            self.redirect('/home')
        else:
            template_values = {
                    'page_title': 'Gift Exchange Central Login',
                    'login_url': users.create_login_url(self.request.uri)
                }
            self.add_template_values(template_values)
            self.render_template('login.html')
        return

class HomeHandler(MainWebAppHandler):
    """The home page of the gift exchange app. This finds any events that a user is in"""
    def get(self):
        """The handler for get requests to the home page"""
        google_user = users.get_current_user()
        gift_exchange_key = datamodel.get_gift_exchange_key(_DEFAULT_GIFT_EXCHANGE_NAME)
        user = datamodel.GiftExchangeUser.update_and_retrieve_user(gift_exchange_key, google_user)
        all_participants = []
        if user is not None:
            query = datamodel.GiftExchangeParticipant.get_participants_by_user_query(gift_exchange_key, user.key)
            all_participants = query.fetch(_DEFAULT_MAX_RESULTS)
        participant_list = []
        for participant in all_participants:
            if participant.get_event().is_active():
                participant_list.append(participant)
        if len(participant_list)==1:
            participant = participant_list[0]
            self.redirect('/main?gift_exchange_participant=' + participant.key.urlsafe())
        else:
            self.add_template_values({'participant_list': participant_list })
            self.render_template('home.html')
        return

class MainHandler(MainWebAppHandler):
    """The main page for a given event. Requires a specific participant"""
    @participant_required
    def get(self):
        """Handles get requests for the main page of a given event."""
        gift_exchange_participant = self.get_participant()
        gift_exchange_key = datamodel.get_gift_exchange_key(_DEFAULT_GIFT_EXCHANGE_NAME)
        target_participant = datamodel.GiftExchangeParticipant.get_participant_by_name(
                                                                            gift_exchange_key, 
                                                                            gift_exchange_participant.target,
                                                                            gift_exchange_participant.event_key)
        target_idea_list = []
        target_messages = []
        giver_messages = []
        if target_participant is not None:
            query = datamodel.GiftExchangeMessage.get_message_exchange_query(gift_exchange_key, gift_exchange_participant, target_participant)
            target_messages = query.fetch(_DEFAULT_MAX_RESULTS)
            for idea in target_participant.idea_list:
                target_idea_list.append(datamodel.free_text_to_safe_html_markup(idea, 60))           
        giver = gift_exchange_participant.get_giver()
        if giver:
            query = datamodel.GiftExchangeMessage.get_message_exchange_query(gift_exchange_key, giver, gift_exchange_participant)
            giver_messages = query.fetch(_DEFAULT_MAX_RESULTS)
        template_values = {
                'page_title': gift_exchange_participant.get_event().display_name + ' Homepage',
                'gift_exchange_participant': gift_exchange_participant,
                'target_participant': target_participant,
                'target_idea_list': target_idea_list,
                'target_messages': target_messages,
                'giver_messages': giver_messages,
                'money_limit': gift_exchange_participant.get_event().money_limit,
            }
        self.add_template_values(template_values)
        self.render_template('main.html')
  
class UpdateHandler(MainWebAppHandler):
    """Class that handles updates to the participant's ideas"""
    @participant_required
    def post(self):
        """This handles post requests. Requires a JSON object"""
        data = json.loads(self.request.body)
        message = 'Ideas could not be updated'
        gift_exchange_participant = self.get_participant()
        if gift_exchange_participant is not None:
            idea_list = data['idea_list'] 
            gift_exchange_participant.idea_list = idea_list
            gift_exchange_participant.put()
            message = 'Ideas successfully updated'
            giver = gift_exchange_participant.get_giver()
            if giver is not None:
                user = giver.get_user()
                if user.email and user.subscribed_to_updates:
                    body = gift_exchange_participant.display_name + ' has updated their profile with new ideas for '
                    body = body + gift_exchange_participant.get_event().display_name
                    body = body + '\n\n'
                    for idea in idea_list:
                        body = body + idea + '\n'
                    #Given that ideas are updated on every save, would only want to send message on navigating away from page
                    #email_subject = gift_exchange_participant.get_event().display_name + ' Gift Idea Update'
                    #url_length = len(self.request.url) - len(self.request.query_string) - len('update?') + 1
                    #unsubscribe_link = self.request.url[0:url_length] + 'unsubscribe?gift_exchange_participant=' + giver.key.urlsafe()
                    #send_email_helper(giver, email_subject, body, unsubscribe_link)
        self.response.out.write(json.dumps(({'message': message})))
        
class AssignmentHandler(MainWebAppHandler):
    """The handler for assigning requests."""
    @participant_required
    def post(self):
        """This handles the post request for assigning users. Requires a JSON object"""
        target = ''
        gift_exchange_participant = self.get_participant()
        if gift_exchange_participant is not None:
            gift_exchange_participant.is_target_known = True
            target = gift_exchange_participant.target
            gift_exchange_participant.put()
        self.response.out.write(json.dumps(({'target': target})))

class PreferencesHandler(MainWebAppHandler):
    """The handler for updating preferences."""
    def get(self):
        """Handles get requests and serves up the preference page."""
        google_user = users.get_current_user()
        gift_exchange_key = datamodel.get_gift_exchange_key(_DEFAULT_GIFT_EXCHANGE_NAME)
        user = datamodel.GiftExchangeUser.get_user_by_google_id(gift_exchange_key, google_user.user_id())
        template_values = {
                           'page_title': 'User Preferences',
                           'user': user,
                        }
        self.add_template_values(template_values)
        self.render_template('preferences.html')
    
    def post(self):
        """Handles posts requests for updating preferences. Requires a JSON object."""
        data = json.loads(self.request.body)
        subscribed_string = data['subscribed_string']
        subscribed_to_updates = True
        if subscribed_string == 'no':
            subscribed_to_updates = False
        google_user = users.get_current_user()
        gift_exchange_key = datamodel.get_gift_exchange_key(_DEFAULT_GIFT_EXCHANGE_NAME)
        user = datamodel.GiftExchangeUser.get_user_by_google_id(gift_exchange_key, google_user.user_id())
        if user is None:
            user = datamodel.GiftExchangeUser.update_and_retrieve_user(gift_exchange_key, google_user)
        if user.subscribed_to_updates != subscribed_to_updates:
            user.subscribed_to_updates = subscribed_to_updates
            user.put()
        self.response.out.write(json.dumps(({'message': 'Preferences Updated Successfully'})))

class UnsubscribeHandler(MainWebAppHandler):
    """Handles unsubscribing a user"""
    def get(self):
        """Handles get requests for unsubscribing"""
        #Don't require a user to be logged in to unsubcribe.
        #This means that anybody can be unsubscribed with merely a link, but that is better
        #  than being aggressive about disallowing unsubscribes, and the GUID shouldn't
        #  be easy to reproduce
        gift_exchange_participant = self.get_participant()
        if gift_exchange_participant is not None:
            user = gift_exchange_participant.get_user()
            if not user.subscribed_to_updates:
                user.subscribed_to_updates = False
                user.put()
            self.add_template_values({'page_title': 'Successfully unsubscribed'})
            self.render_template('unsubscribe.html')
            return
        self.redirect('/home')

class MessageHandler(MainWebAppHandler):
    """Handler for page to send anonymous messages to your target"""
    @participant_required
    def post(self):
        """Handles posts requests for the message class. Will send an email to the target. Requires a JSON object"""
        data = json.loads(self.request.body)
        message = 'Could not send message'
        gift_exchange_participant = self.get_participant()
        participant_key = gift_exchange_participant.key.urlsafe()
        gift_exchange_key = datamodel.get_gift_exchange_key(_DEFAULT_GIFT_EXCHANGE_NAME)
        message_type = data['message_type']
        email_body = data['email_body']
        if not email_body:
            message = 'Nothing to send'
        else:
            if message_type == 'target':
                target_participant = datamodel.GiftExchangeParticipant.get_participant_by_name(
                                                                                gift_exchange_key, 
                                                                                gift_exchange_participant.target,
                                                                                gift_exchange_participant.event_key)
                if target_participant.get_user().email:
                    message = 'Message successfully sent'
                    send_email_helper(target_participant, 'Your Secret Santa Has Sent You A Message', email_body, None)
                message_type_enum = datamodel.message_type_to_target
                datamodel.GiftExchangeMessage.create_message(gift_exchange_key, gift_exchange_participant.key, message_type_enum, email_body)
            elif message_type == 'giver':
                giver = gift_exchange_participant.get_giver()
                message = 'Message successfully sent'
                if giver is not None:
                    if giver.get_user().email:
                        send_email_helper(giver, gift_exchange_participant.display_name + ' Has Sent You A Message', email_body, None)
                message_type_enum = datamodel.message_type_to_giver
                datamodel.GiftExchangeMessage.create_message(gift_exchange_key, gift_exchange_participant.key, message_type_enum, email_body)
        self.response.out.write(json.dumps(({'message': message, 'gift_exchange_participant_key': participant_key})))

app = webapp2.WSGIApplication([
    ('/', LoginHandler),
    ('/login', LoginHandler),
    ('/main', MainHandler),
    ('/home', HomeHandler),
    ('/preferences', PreferencesHandler),
    ('/message', MessageHandler),
    ('/update', UpdateHandler),
    ('/unsubscribe', UnsubscribeHandler),
    ('/assign', AssignmentHandler)
], debug=False)
